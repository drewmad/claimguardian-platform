/**
 * @fileMetadata
 * @purpose "Server actions for intelligent document management"
 * @owner backend-team
 * @dependencies ["@supabase/supabase-js", "@/lib/logger"]
 * @exports ["uploadDocument", "searchDocuments", "getDocumentInsights"]
 * @complexity high
 * @tags ["server-actions", "documents", "ai"]
 * @status stable
 */

"use server";

import { createClient } from "@/lib/supabase/server";
import { logger } from "@/lib/logger";
import {
  DocumentSearchResult,
  SearchQuery,
  DocumentInsight,
} from "@/lib/services/intelligent-document-search";

export interface DocumentUpload {
  title: string;
  content: string;
  documentType:
    | "policy"
    | "claim"
    | "warranty"
    | "receipt"
    | "contract"
    | "correspondence"
    | "other";
  filePath?: string;
  fileSize?: number;
  mimeType?: string;
  propertyId?: string;
  claimId?: string;
}

export async function uploadDocument(
  documentData: DocumentUpload,
): Promise<{ success: boolean; error?: string; documentId?: string }> {
  try {
    const supabase = await createClient();

    // Get current user
    const {
      data: { user },
      error: userError,
    } = await supabase.auth.getUser();
    if (userError || !user) {
      return { success: false, error: "Authentication required" };
    }

    logger.info("Uploading document", {
      userId: user.id,
      documentType: documentData.documentType,
      title: documentData.title,
    });

    // Insert document record
    const { data, error } = await supabase
      .from("documents")
      .insert({
        user_id: user.id,
        title: documentData.title,
        content: documentData.content,
        document_type: documentData.documentType,
        file_path: documentData.filePath,
        file_size: documentData.fileSize,
        mime_type: documentData.mimeType,
        property_id: documentData.propertyId,
        claim_id: documentData.claimId,
        // Note: content_embedding will be generated by AI service
        extracted_entities: [],
        key_terms: [],
        confidence_score: 0.0,
      })
      .select()
      .single();

    if (error) {
      logger.error("Failed to upload document", { error: error.message });
      return { success: false, error: error.message };
    }

    logger.info("Document uploaded successfully", { documentId: data.id });
    return { success: true, documentId: data.id };
  } catch (error) {
    logger.error("Unexpected error during document upload", { error: error instanceof Error ? error.message : String(error) });
    return { success: false, error: "Failed to upload document" };
  }
}

export async function getDocumentInsights(): Promise<{
  success: boolean;
  insights?: DocumentInsight[];
  error?: string;
}> {
  try {
    const supabase = await createClient();

    // Get current user
    const {
      data: { user },
      error: userError,
    } = await supabase.auth.getUser();
    if (userError || !user) {
      return { success: false, error: "Authentication required" };
    }

    logger.info("Generating document insights", { userId: user.id });

    // Get document counts by type
    const { data: docStats, error: statsError } = await supabase
      .from("documents")
      .select("document_type")
      .eq("user_id", user.id);

    if (statsError) {
      logger.error("Failed to get document stats", { error: statsError.message });
      return { success: false, error: statsError.message };
    }

    const stats =
      docStats?.reduce(
        (acc, doc) => {
          acc[doc.document_type] = (acc[doc.document_type] || 0) + 1;
          return acc;
        },
        {} as Record<string, number>,
      ) || {};

    // Generate insights based on document analysis
    const insights: DocumentInsight[] = [];

    // No policies insight
    if (!stats.policy || stats.policy === 0) {
      insights.push({
        type: "document_missing",
        title: "No Insurance Policies Found",
        description:
          "Upload your insurance policies to get personalized coverage analysis and recommendations.",
        severity: "high",
        actionItems: [
          "Upload homeowner's insurance policy",
          "Add flood insurance documents if applicable",
          "Upload any additional coverage policies",
        ],
        relatedDocuments: [],
      });
    }

    // Claims opportunity
    if (stats.claim && stats.claim > 0) {
      insights.push({
        type: "claim_opportunity",
        title: "Previous Claims Detected",
        description: `You have ${stats.claim} claim document(s). Review them to identify potential coverage improvements.`,
        severity: "medium",
        actionItems: [
          "Review previous claim outcomes",
          "Identify coverage gaps from past claims",
          "Consider policy adjustments based on claim history",
        ],
        relatedDocuments: [],
      });
    }

    // Warranty expiration warnings
    if (stats.warranty && stats.warranty > 0) {
      insights.push({
        type: "expiration_warning",
        title: "Warranty Documents Available",
        description: `You have ${stats.warranty} warranty document(s). Check expiration dates to ensure continued coverage.`,
        severity: "medium",
        actionItems: [
          "Review warranty expiration dates",
          "Contact providers for renewal options",
          "Schedule maintenance before warranties expire",
        ],
        relatedDocuments: [],
      });
    }

    // Document organization
    const totalDocs = Object.values(stats).reduce(
      (sum, count) => sum + count,
      0,
    );
    if (totalDocs > 10) {
      insights.push({
        type: "action_required",
        title: "Document Organization Opportunity",
        description: `You have ${totalDocs} documents. Consider organizing them by property or claim for better management.`,
        severity: "low",
        actionItems: [
          "Tag documents by property",
          "Link documents to relevant claims",
          "Create document categories for easy access",
        ],
        relatedDocuments: [],
      });
    }

    logger.info("Generated document insights", {
      userId: user.id,
      insightsCount: insights.length,
    });

    return { success: true, insights };
  } catch (error) {
    logger.error("Unexpected error generating document insights", { error: error instanceof Error ? error.message : String(error) });
    return { success: false, error: "Failed to generate insights" };
  }
}

// Helper functions
function extractHighlights(content: string, query: string): string[] {
  if (!content || !query) return [];

  const words = query.toLowerCase().split(" ");
  const sentences = content.split(/[.!?]+/);
  const highlights: string[] = [];

  sentences.forEach((sentence) => {
    const lowerSentence = sentence.toLowerCase();
    if (words.some((word) => lowerSentence.includes(word))) {
      highlights.push(sentence.trim());
    }
  });

  return highlights.slice(0, 3); // Return top 3 highlights
}

function generateMockSummary(documentType: string): string {
  const summaries = {
    policy:
      "Insurance policy with coverage details, deductibles, and important terms and conditions.",
    claim:
      "Insurance claim documentation with damage details, estimates, and processing information.",
    warranty:
      "Product or service warranty with coverage terms, expiration dates, and contact information.",
    receipt:
      "Purchase receipt for items that may be covered under insurance or warranty claims.",
    contract:
      "Service or purchase contract with terms, conditions, and warranty information.",
    correspondence:
      "Communication regarding insurance, claims, or property-related matters.",
    other: "Important document related to your property, insurance, or claims.",
  };

  return summaries[documentType as keyof typeof summaries] || summaries.other;
}

function generateMockActionItems(documentType: string): string[] {
  const actionItems = {
    policy: [
      "Review coverage limits",
      "Check for exclusions",
      "Verify contact information",
      "Note renewal date",
    ],
    claim: [
      "Track claim status",
      "Gather supporting docs",
      "Follow up with adjuster",
      "Document all communications",
    ],
    warranty: [
      "Check expiration date",
      "Review covered items",
      "Save contact information",
      "Schedule maintenance",
    ],
    receipt: [
      "Keep for insurance claims",
      "File for tax purposes",
      "Link to warranty info",
      "Store safely",
    ],
    contract: [
      "Review payment terms",
      "Check completion dates",
      "File warranty info",
      "Monitor service quality",
    ],
    correspondence: [
      "Reply if needed",
      "File with related docs",
      "Follow up as required",
      "Save contact details",
    ],
    other: [
      "Review and categorize",
      "Link to relevant claims",
      "Update related records",
      "Store securely",
    ],
  };

  return (
    actionItems[documentType as keyof typeof actionItems] || actionItems.other
  );
}

// Policy document specific functions (for compatibility with existing hooks)
export async function uploadPolicyDocument(data: {
  files: FileList;
  propertyId: string;
}) {
  // Process first file for now
  const file = data.files[0];
  if (!file) {
    return { success: false, error: "No file provided" };
  }

  const content = await file.text(); // Simple text extraction - in production would use AI

  return uploadDocument({
    title: file.name,
    content,
    documentType: "policy",
    filePath: "", // Would be set after Supabase storage upload
    fileSize: file.size,
    mimeType: file.type,
    propertyId: data.propertyId,
  });
}

export async function getPolicyDocuments(propertyId: string) {
  try {
    const supabase = await createClient();

    const {
      data: { user },
      error: userError,
    } = await supabase.auth.getUser();
    if (userError || !user) {
      return { success: false, error: "Authentication required", data: null };
    }

    const { data, error } = await supabase
      .from("documents")
      .select("*")
      .eq("user_id", user.id)
      .eq("property_id", propertyId)
      .eq("document_type", "policy")
      .order("created_at", { ascending: false });

    if (error) {
      logger.error("Failed to get policy documents", { error: error.message });
      return { success: false, error: error.message, data: null };
    }

    return { success: true, data };
  } catch (error) {
    logger.error("Unexpected error getting policy documents", { error: error instanceof Error ? error.message : String(error) });
    return {
      success: false,
      error: "Failed to get policy documents",
      data: null,
    };
  }
}

export async function deletePolicyDocument(documentId: string) {
  try {
    const supabase = await createClient();

    const {
      data: { user },
      error: userError,
    } = await supabase.auth.getUser();
    if (userError || !user) {
      return { success: false, error: "Authentication required", data: null };
    }

    const { error } = await supabase
      .from("documents")
      .delete()
      .eq("id", documentId)
      .eq("user_id", user.id)
      .eq("document_type", "policy");

    if (error) {
      logger.error("Failed to delete policy document", { error: error.message });
      return { success: false, error: error.message, data: null };
    }

    return { success: true, data: true };
  } catch (error) {
    logger.error("Unexpected error deleting policy document", { error: error instanceof Error ? error.message : String(error) });
    return {
      success: false,
      error: "Failed to delete policy document",
      data: null,
    };
  }
}

export async function getDocumentDownloadUrl(documentId: string) {
  try {
    const supabase = await createClient();

    const {
      data: { user },
      error: userError,
    } = await supabase.auth.getUser();
    if (userError || !user) {
      return { success: false, error: "Authentication required", data: null };
    }

    const { data, error } = await supabase
      .from("documents")
      .select("file_path, title")
      .eq("id", documentId)
      .eq("user_id", user.id)
      .single();

    if (error) {
      logger.error("Failed to get document download URL", { error: error.message });
      return { success: false, error: error.message, data: null };
    }

    // In production, this would get a signed URL from Supabase storage
    // For now, return a placeholder
    return {
      success: true,
      data: {
        url: `/api/documents/${documentId}/download`,
        filename: data.title,
      },
    };
  } catch (error) {
    logger.error("Unexpected error getting document download URL", { error: error instanceof Error ? error.message : String(error) });
    return { success: false, error: "Failed to get download URL", data: null };
  }
}

export async function createDocumentRecord(data: {
  fileName: string;
  fileSize: number;
  propertyId: string;
  documentType: string;
}) {
  return uploadDocument({
    title: data.fileName,
    content: "", // Will be populated when file is processed
    documentType: data.documentType as any,
    fileSize: data.fileSize,
    propertyId: data.propertyId,
  });
}
