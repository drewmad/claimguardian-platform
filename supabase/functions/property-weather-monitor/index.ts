import \"jsr:@supabase/functions-js/edge-runtime.d.ts\"\nimport { createClient } from \"https://esm.sh/@supabase/supabase-js@2.39.0\"\n\n/**\n * Property Weather Monitor\n * Monitors all properties for severe weather conditions and sends real-time alerts\n */\n\nconst corsHeaders = {\n  'Access-Control-Allow-Origin': '*',\n  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',\n}\n\ninterface PropertyAlert {\n  property_id: string\n  user_id: string\n  alert_type: string\n  severity: string\n  conditions: any\n  distance_from_event: number\n}\n\nDeno.serve(async (req: Request) => {\n  if (req.method === 'OPTIONS') {\n    return new Response('ok', { headers: corsHeaders })\n  }\n\n  const supabase = createClient(\n    Deno.env.get('SUPABASE_URL') ?? '',\n    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''\n  )\n\n  try {\n    const { action } = await req.json().catch(() => ({ action: 'monitor-all' }))\n    console.log(`Property Weather Monitor: ${action}`)\n\n    switch (action) {\n      case 'monitor-all':\n        return await monitorAllProperties(supabase)\n      case 'check-property':\n        const { property_id } = await req.json()\n        return await checkSingleProperty(supabase, property_id)\n      case 'generate-alerts':\n        return await generateWeatherAlerts(supabase)\n      default:\n        return await monitorAllProperties(supabase)\n    }\n  } catch (error) {\n    console.error('Property Weather Monitor error:', error)\n    return new Response(\n      JSON.stringify({ error: error.message }),\n      { \n        status: 500,\n        headers: { ...corsHeaders, 'Content-Type': 'application/json' }\n      }\n    )\n  }\n})\n\nasync function monitorAllProperties(supabase: any) {\n  console.log('Monitoring all properties for severe weather...')\n  \n  // Get all active properties with coordinates\n  const { data: properties, error: propError } = await supabase\n    .from('properties')\n    .select(`\n      id,\n      user_id,\n      full_address,\n      latitude,\n      longitude,\n      location\n    `)\n    .not('latitude', 'is', null)\n    .not('longitude', 'is', null)\n\n  if (propError) {\n    console.error('Error fetching properties:', propError)\n    throw propError\n  }\n\n  console.log(`Found ${properties.length} properties to monitor`)\n\n  const alerts = []\n  const processedProperties = []\n\n  for (const property of properties) {\n    try {\n      const propertyAlerts = await checkPropertyWeatherConditions(supabase, property)\n      alerts.push(...propertyAlerts)\n      processedProperties.push({\n        property_id: property.id,\n        address: property.full_address,\n        alerts_generated: propertyAlerts.length\n      })\n    } catch (error) {\n      console.error(`Error checking property ${property.id}:`, error)\n    }\n  }\n\n  // Store alerts in database\n  if (alerts.length > 0) {\n    const { error: insertError } = await supabase\n      .from('property_weather_alerts')\n      .insert(alerts)\n\n    if (insertError) {\n      console.error('Error inserting alerts:', insertError)\n    } else {\n      console.log(`Generated ${alerts.length} weather alerts`)\n    }\n\n    // Send real-time notifications\n    for (const alert of alerts) {\n      await supabase\n        .channel('property-alerts')\n        .send({\n          type: 'broadcast',\n          event: 'weather-alert',\n          payload: alert\n        })\n    }\n  }\n\n  // Log monitoring activity\n  await supabase\n    .from('noaa_ingestion_logs')\n    .insert({\n      data_type: 'property_monitoring',\n      severity_level: alerts.length > 0 ? 'elevated' : 'normal',\n      records_processed: properties.length,\n      metadata: {\n        alerts_generated: alerts.length,\n        properties_processed: processedProperties\n      }\n    })\n\n  return new Response(\n    JSON.stringify({\n      success: true,\n      properties_monitored: properties.length,\n      alerts_generated: alerts.length,\n      timestamp: new Date().toISOString()\n    }),\n    { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n  )\n}\n\nasync function checkPropertyWeatherConditions(supabase: any, property: any): Promise<PropertyAlert[]> {\n  const alerts: PropertyAlert[] = []\n  const lat = property.latitude\n  const lon = property.longitude\n\n  // 1. Check for active storm warnings/watches\n  const { data: stormAlerts } = await supabase\n    .rpc('is_property_in_alert_zone', {\n      property_lat: lat,\n      property_lon: lon\n    })\n\n  if (stormAlerts && stormAlerts.length > 0) {\n    for (const alert of stormAlerts) {\n      alerts.push({\n        property_id: property.id,\n        user_id: property.user_id,\n        alert_type: 'storm_warning',\n        severity: alert.severity?.toLowerCase() || 'moderate',\n        conditions: {\n          event_type: alert.event_type,\n          headline: alert.headline,\n          expires: alert.expires\n        },\n        distance_from_event: 0\n      })\n    }\n  }\n\n  // 2. Check for high winds at nearby stations\n  const { data: nearbyStations } = await supabase\n    .rpc('find_nearest_weather_station', {\n      user_lat: lat,\n      user_lon: lon,\n      max_distance_km: 50\n    })\n\n  if (nearbyStations && nearbyStations.length > 0) {\n    // Get recent observations from nearest stations\n    const stationIds = nearbyStations.slice(0, 3).map(s => s.station_id)\n    \n    const { data: observations } = await supabase\n      .from('noaa_weather_observations')\n      .select('*')\n      .in('station_id', stationIds)\n      .gte('observation_time', new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString())\n      .order('observation_time', { ascending: false })\n\n    if (observations) {\n      for (const obs of observations) {\n        const windSpeed = obs.wind_speed || 0\n        const windGust = obs.wind_gust || 0\n        \n        // High wind alert\n        if (windSpeed > 25 || windGust > 35) {\n          alerts.push({\n            property_id: property.id,\n            user_id: property.user_id,\n            alert_type: 'high_winds',\n            severity: windSpeed > 35 || windGust > 50 ? 'severe' : 'moderate',\n            conditions: {\n              wind_speed: windSpeed,\n              wind_gust: windGust,\n              station_id: obs.station_id,\n              observation_time: obs.observation_time\n            },\n            distance_from_event: nearbyStations.find(s => s.station_id === obs.station_id)?.distance_km || 0\n          })\n        }\n      }\n    }\n  }\n\n  // 3. Check for lightning strikes nearby\n  const { data: lightningStrikes } = await supabase\n    .from('noaa_lightning_strikes')\n    .select('*')\n    .gte('detection_time', new Date(Date.now() - 30 * 60 * 1000).toISOString()) // Last 30 minutes\n\n  if (lightningStrikes) {\n    // Count strikes within different radii\n    let nearbyStrikes = 0\n    let closeStrikes = 0\n    \n    for (const strike of lightningStrikes) {\n      if (strike.latitude && strike.longitude) {\n        const distance = calculateDistance(lat, lon, strike.latitude, strike.longitude)\n        \n        if (distance < 10) { // Within 10km\n          nearbyStrikes++\n          if (distance < 3) { // Within 3km\n            closeStrikes++\n          }\n        }\n      }\n    }\n    \n    if (closeStrikes > 0 || nearbyStrikes > 5) {\n      alerts.push({\n        property_id: property.id,\n        user_id: property.user_id,\n        alert_type: 'lightning_activity',\n        severity: closeStrikes > 0 ? 'severe' : 'moderate',\n        conditions: {\n          close_strikes: closeStrikes,\n          nearby_strikes: nearbyStrikes,\n          time_period: '30 minutes'\n        },\n        distance_from_event: closeStrikes > 0 ? 0 : 5 // Approximate\n      })\n    }\n  }\n\n  // 4. Check for coastal flooding (if near coast)\n  const { data: tideData } = await supabase\n    .from('noaa_tide_and_current_data')\n    .select('*')\n    .gte('observation_time', new Date(Date.now() - 60 * 60 * 1000).toISOString()) // Last hour\n    .order('observation_time', { ascending: false })\n    .limit(10)\n\n  if (tideData) {\n    for (const tide of tideData) {\n      // Check if property is near this tide station (rough approximation)\n      if (tide.water_level > 3.0) { // High water level threshold\n        alerts.push({\n          property_id: property.id,\n          user_id: property.user_id,\n          alert_type: 'coastal_flooding',\n          severity: tide.water_level > 4.0 ? 'severe' : 'moderate',\n          conditions: {\n            water_level: tide.water_level,\n            station_name: tide.station_name,\n            observation_time: tide.observation_time\n          },\n          distance_from_event: 20 // Approximate for coastal properties\n        })\n      }\n    }\n  }\n\n  return alerts\n}\n\nasync function checkSingleProperty(supabase: any, propertyId: string) {\n  const { data: property, error } = await supabase\n    .from('properties')\n    .select('*')\n    .eq('id', propertyId)\n    .single()\n\n  if (error || !property) {\n    throw new Error('Property not found')\n  }\n\n  const alerts = await checkPropertyWeatherConditions(supabase, property)\n  \n  return new Response(\n    JSON.stringify({\n      property_id: propertyId,\n      alerts,\n      alert_count: alerts.length\n    }),\n    { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n  )\n}\n\nasync function generateWeatherAlerts(supabase: any) {\n  // Get all unresolved alerts for notification\n  const { data: alerts, error } = await supabase\n    .from('property_weather_alerts')\n    .select(`\n      *,\n      properties!inner(full_address, user_id)\n    `)\n    .eq('resolved', false)\n    .gte('created_at', new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString())\n\n  if (error) {\n    throw error\n  }\n\n  console.log(`Found ${alerts.length} active weather alerts`)\n\n  // Group alerts by user for batching\n  const userAlerts = alerts.reduce((acc, alert) => {\n    const userId = alert.user_id\n    if (!acc[userId]) {\n      acc[userId] = []\n    }\n    acc[userId].push(alert)\n    return acc\n  }, {})\n\n  // Send notifications (placeholder - would integrate with email/SMS service)\n  const notifications = []\n  for (const [userId, userAlertList] of Object.entries(userAlerts)) {\n    notifications.push({\n      user_id: userId,\n      alert_count: userAlertList.length,\n      most_severe: userAlertList.reduce((max, alert) => \n        alert.severity === 'severe' ? alert : max, userAlertList[0]\n      )\n    })\n  }\n\n  return new Response(\n    JSON.stringify({\n      alerts_processed: alerts.length,\n      users_notified: notifications.length,\n      notifications\n    }),\n    { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n  )\n}\n\n// Helper function to calculate distance between two points\nfunction calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {\n  const R = 6371 // Earth's radius in km\n  const dLat = (lat2 - lat1) * Math.PI / 180\n  const dLon = (lon2 - lon1) * Math.PI / 180\n  const a = \n    Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n    Math.sin(dLon / 2) * Math.sin(dLon / 2)\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))\n  return R * c\n}"
