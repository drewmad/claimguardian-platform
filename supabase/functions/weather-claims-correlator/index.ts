import \"jsr:@supabase/functions-js/edge-runtime.d.ts\"\nimport { createClient } from \"https://esm.sh/@supabase/supabase-js@2.39.0\"\n\n/**\n * Weather Claims Correlator\n * Automatically correlates insurance claims with weather events for evidence and documentation\n */\n\nconst corsHeaders = {\n  'Access-Control-Allow-Origin': '*',\n  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',\n}\n\ninterface WeatherCorrelation {\n  claim_id: string\n  weather_events: any[]\n  severity_score: number\n  evidence_strength: string\n  correlation_details: any\n}\n\nDeno.serve(async (req: Request) => {\n  if (req.method === 'OPTIONS') {\n    return new Response('ok', { headers: corsHeaders })\n  }\n\n  const supabase = createClient(\n    Deno.env.get('SUPABASE_URL') ?? '',\n    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''\n  )\n\n  try {\n    const body = await req.json().catch(() => ({}))\n    const { action, claim_id, timeframe_days = 3 } = body\n    \n    console.log(`Weather Claims Correlator: ${action || 'correlate-all'}`)\n\n    switch (action) {\n      case 'correlate-claim':\n        if (!claim_id) throw new Error('claim_id required')\n        return await correlateSingleClaim(supabase, claim_id, timeframe_days)\n      \n      case 'correlate-recent':\n        return await correlateRecentClaims(supabase, timeframe_days)\n      \n      case 'auto-documentation':\n        if (!claim_id) throw new Error('claim_id required')\n        return await generateClaimWeatherDocumentation(supabase, claim_id)\n      \n      case 'severity-analysis':\n        return await analyzeClaimSeverityPatterns(supabase)\n        \n      default:\n        return await correlateRecentClaims(supabase, timeframe_days)\n    }\n  } catch (error) {\n    console.error('Weather Claims Correlator error:', error)\n    return new Response(\n      JSON.stringify({ error: error.message }),\n      { \n        status: 500,\n        headers: { ...corsHeaders, 'Content-Type': 'application/json' }\n      }\n    )\n  }\n})\n\nasync function correlateSingleClaim(supabase: any, claimId: string, timeframeDays: number) {\n  console.log(`Correlating claim ${claimId} with weather events`)\n  \n  // Get claim details\n  const { data: claim, error: claimError } = await supabase\n    .from('claims')\n    .select(`\n      *,\n      properties!inner(\n        id,\n        full_address,\n        latitude,\n        longitude,\n        location\n      )\n    `)\n    .eq('id', claimId)\n    .single()\n\n  if (claimError || !claim) {\n    throw new Error('Claim not found')\n  }\n\n  const property = claim.properties\n  if (!property.latitude || !property.longitude) {\n    throw new Error('Property coordinates required for weather correlation')\n  }\n\n  // Calculate time window for weather events\n  const claimDate = new Date(claim.date_of_loss || claim.created_at)\n  const startDate = new Date(claimDate.getTime() - timeframeDays * 24 * 60 * 60 * 1000)\n  const endDate = new Date(claimDate.getTime() + 24 * 60 * 60 * 1000) // Include day after claim\n\n  console.log(`Searching for weather events between ${startDate.toISOString()} and ${endDate.toISOString()}`)\n\n  const correlation = await findWeatherEventsForClaim(\n    supabase, \n    claim, \n    property, \n    startDate, \n    endDate\n  )\n\n  // Store correlation results\n  await supabase\n    .from('weather_claim_correlations')\n    .upsert({\n      claim_id: claimId,\n      property_id: property.id,\n      correlation_data: correlation,\n      severity_score: correlation.severity_score,\n      evidence_strength: correlation.evidence_strength,\n      correlated_at: new Date().toISOString()\n    }, { onConflict: 'claim_id' })\n\n  return new Response(\n    JSON.stringify({\n      claim_id: claimId,\n      correlation: correlation,\n      weather_events_found: correlation.weather_events.length\n    }),\n    { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n  )\n}\n\nasync function findWeatherEventsForClaim(\n  supabase: any, \n  claim: any, \n  property: any, \n  startDate: Date, \n  endDate: Date\n): Promise<WeatherCorrelation> {\n  const weatherEvents = []\n  const lat = property.latitude\n  const lon = property.longitude\n  \n  // 1. Check for storm events/warnings\n  const { data: stormEvents } = await supabase\n    .from('noaa_storm_events')\n    .select('*')\n    .gte('effective', startDate.toISOString())\n    .lte('effective', endDate.toISOString())\n\n  if (stormEvents) {\n    for (const event of stormEvents) {\n      if (event.geometry) {\n        // Check if property was in the affected area\n        const { data: inZone } = await supabase\n          .rpc('is_property_in_alert_zone', {\n            property_lat: lat,\n            property_lon: lon\n          })\n        \n        if (inZone && inZone.length > 0) {\n          weatherEvents.push({\n            type: 'storm_event',\n            event: event,\n            relevance: 'direct', // Property was in warning zone\n            severity: event.severity,\n            time_correlation: calculateTimeCorrelation(new Date(claim.date_of_loss), new Date(event.effective))\n          })\n        }\n      }\n    }\n  }\n\n  // 2. Check for severe weather observations\n  const { data: nearbyStations } = await supabase\n    .rpc('find_nearest_weather_station', {\n      user_lat: lat,\n      user_lon: lon,\n      max_distance_km: 50\n    })\n\n  if (nearbyStations && nearbyStations.length > 0) {\n    const stationIds = nearbyStations.slice(0, 3).map(s => s.station_id)\n    \n    const { data: observations } = await supabase\n      .from('noaa_weather_observations')\n      .select('*')\n      .in('station_id', stationIds)\n      .gte('observation_time', startDate.toISOString())\n      .lte('observation_time', endDate.toISOString())\n      .order('observation_time', { ascending: true })\n\n    if (observations) {\n      // Look for extreme conditions\n      const severeObservations = observations.filter(obs => {\n        const windSpeed = obs.wind_speed || 0\n        const windGust = obs.wind_gust || 0\n        const precipitation = obs.precipitation_last_hour || 0\n        \n        return windSpeed > 25 || windGust > 35 || precipitation > 25 // mm\n      })\n\n      if (severeObservations.length > 0) {\n        // Group observations by severity\n        const maxWind = Math.max(...severeObservations.map(o => Math.max(o.wind_speed || 0, o.wind_gust || 0)))\n        const maxPrecip = Math.max(...severeObservations.map(o => o.precipitation_last_hour || 0))\n        \n        weatherEvents.push({\n          type: 'severe_weather',\n          observations: severeObservations,\n          max_wind_speed: maxWind,\n          max_precipitation: maxPrecip,\n          station_distances: nearbyStations.map(s => ({ id: s.station_id, distance: s.distance_km })),\n          relevance: 'nearby', // From nearby weather stations\n          severity: maxWind > 50 || maxPrecip > 50 ? 'severe' : 'moderate'\n        })\n      }\n    }\n  }\n\n  // 3. Check for lightning activity\n  const { data: lightningStrikes } = await supabase\n    .from('noaa_lightning_strikes')\n    .select('*')\n    .gte('detection_time', startDate.toISOString())\n    .lte('detection_time', endDate.toISOString())\n\n  if (lightningStrikes) {\n    let nearbyStrikes = 0\n    let closeStrikes = 0\n    \n    for (const strike of lightningStrikes) {\n      if (strike.latitude && strike.longitude) {\n        const distance = calculateDistance(lat, lon, strike.latitude, strike.longitude)\n        \n        if (distance < 20) { // Within 20km\n          nearbyStrikes++\n          if (distance < 5) { // Within 5km\n            closeStrikes++\n          }\n        }\n      }\n    }\n    \n    if (nearbyStrikes > 0) {\n      weatherEvents.push({\n        type: 'lightning_activity',\n        total_strikes: lightningStrikes.length,\n        nearby_strikes: nearbyStrikes,\n        close_strikes: closeStrikes,\n        relevance: closeStrikes > 0 ? 'direct' : 'nearby',\n        severity: closeStrikes > 5 ? 'severe' : nearbyStrikes > 20 ? 'moderate' : 'low'\n      })\n    }\n  }\n\n  // 4. Check for flooding conditions\n  const { data: riverGauges } = await supabase\n    .from('noaa_river_gauges')\n    .select('*')\n    .gte('observation_time', startDate.toISOString())\n    .lte('observation_time', endDate.toISOString())\n    .eq('current_status', 'flood')\n\n  if (riverGauges && riverGauges.length > 0) {\n    weatherEvents.push({\n      type: 'flooding',\n      gauges: riverGauges,\n      relevance: 'regional',\n      severity: riverGauges.some(g => g.current_status === 'major_flood') ? 'severe' : 'moderate'\n    })\n  }\n\n  // Calculate overall correlation strength\n  const severityScore = calculateSeverityScore(weatherEvents)\n  const evidenceStrength = determineEvidenceStrength(weatherEvents, claim)\n\n  return {\n    claim_id: claim.id,\n    weather_events: weatherEvents,\n    severity_score: severityScore,\n    evidence_strength: evidenceStrength,\n    correlation_details: {\n      property_location: { lat, lon },\n      search_timeframe: {\n        start: startDate.toISOString(),\n        end: endDate.toISOString(),\n        days: Math.ceil((endDate.getTime() - startDate.getTime()) / (24 * 60 * 60 * 1000))\n      },\n      claim_type: claim.claim_type,\n      estimated_damage: claim.estimated_amount\n    }\n  }\n}\n\nasync function correlateRecentClaims(supabase: any, timeframeDays: number) {\n  // Get recent claims that haven't been correlated yet\n  const { data: claims, error } = await supabase\n    .from('claims')\n    .select(`\n      *,\n      properties!inner(\n        id,\n        full_address,\n        latitude,\n        longitude\n      )\n    `)\n    .gte('created_at', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()) // Last 30 days\n    .is('weather_correlated', false)\n    .limit(20)\n\n  if (error) {\n    throw error\n  }\n\n  console.log(`Correlating ${claims.length} recent claims with weather data`)\n\n  const results = []\n  for (const claim of claims) {\n    try {\n      if (claim.properties.latitude && claim.properties.longitude) {\n        const claimDate = new Date(claim.date_of_loss || claim.created_at)\n        const startDate = new Date(claimDate.getTime() - timeframeDays * 24 * 60 * 60 * 1000)\n        const endDate = new Date(claimDate.getTime() + 24 * 60 * 60 * 1000)\n\n        const correlation = await findWeatherEventsForClaim(\n          supabase,\n          claim,\n          claim.properties,\n          startDate,\n          endDate\n        )\n\n        // Store correlation\n        await supabase\n          .from('weather_claim_correlations')\n          .upsert({\n            claim_id: claim.id,\n            property_id: claim.properties.id,\n            correlation_data: correlation,\n            severity_score: correlation.severity_score,\n            evidence_strength: correlation.evidence_strength,\n            correlated_at: new Date().toISOString()\n          }, { onConflict: 'claim_id' })\n\n        // Mark claim as correlated\n        await supabase\n          .from('claims')\n          .update({ weather_correlated: true })\n          .eq('id', claim.id)\n\n        results.push({\n          claim_id: claim.id,\n          weather_events_found: correlation.weather_events.length,\n          severity_score: correlation.severity_score,\n          evidence_strength: correlation.evidence_strength\n        })\n      }\n    } catch (error) {\n      console.error(`Error correlating claim ${claim.id}:`, error)\n      results.push({\n        claim_id: claim.id,\n        error: error.message\n      })\n    }\n  }\n\n  return new Response(\n    JSON.stringify({\n      claims_processed: claims.length,\n      successful_correlations: results.filter(r => !r.error).length,\n      results\n    }),\n    { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n  )\n}\n\nasync function generateClaimWeatherDocumentation(supabase: any, claimId: string) {\n  // Get correlation data for the claim\n  const { data: correlation, error } = await supabase\n    .from('weather_claim_correlations')\n    .select(`\n      *,\n      claims!inner(\n        *,\n        properties!inner(*)\n      )\n    `)\n    .eq('claim_id', claimId)\n    .single()\n\n  if (error || !correlation) {\n    throw new Error('No weather correlation found for this claim')\n  }\n\n  const claim = correlation.claims\n  const property = claim.properties\n  const weatherData = correlation.correlation_data\n\n  // Generate comprehensive documentation\n  const documentation = {\n    claim_summary: {\n      claim_number: claim.claim_number,\n      property_address: property.full_address,\n      date_of_loss: claim.date_of_loss,\n      claim_type: claim.claim_type,\n      estimated_damage: claim.estimated_amount\n    },\n    weather_evidence: {\n      correlation_strength: correlation.evidence_strength,\n      severity_score: correlation.severity_score,\n      events_summary: generateEventsSummary(weatherData.weather_events),\n      timeline: generateWeatherTimeline(weatherData.weather_events, claim.date_of_loss)\n    },\n    supporting_data: {\n      nearest_weather_stations: extractStationData(weatherData.weather_events),\n      meteorological_conditions: extractConditionsData(weatherData.weather_events),\n      official_warnings: extractWarningsData(weatherData.weather_events)\n    },\n    claim_correlation: {\n      damage_type_weather_match: analyzeDamageWeatherMatch(claim, weatherData.weather_events),\n      timing_analysis: analyzeEventTiming(claim.date_of_loss, weatherData.weather_events),\n      geographic_relevance: analyzeGeographicRelevance(property, weatherData.weather_events)\n    },\n    recommendations: generateClaimRecommendations(claim, weatherData)\n  }\n\n  // Store documentation\n  await supabase\n    .from('claim_weather_documentation')\n    .upsert({\n      claim_id: claimId,\n      documentation: documentation,\n      generated_at: new Date().toISOString(),\n      version: 1\n    }, { onConflict: 'claim_id' })\n\n  return new Response(\n    JSON.stringify({\n      claim_id: claimId,\n      documentation_generated: true,\n      documentation\n    }),\n    { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n  )\n}\n\n// Helper functions\nfunction calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {\n  const R = 6371\n  const dLat = (lat2 - lat1) * Math.PI / 180\n  const dLon = (lon2 - lon1) * Math.PI / 180\n  const a = \n    Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n    Math.sin(dLon / 2) * Math.sin(dLon / 2)\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))\n  return R * c\n}\n\nfunction calculateTimeCorrelation(claimDate: Date, eventDate: Date): number {\n  const diffHours = Math.abs(claimDate.getTime() - eventDate.getTime()) / (60 * 60 * 1000)\n  if (diffHours <= 6) return 1.0 // Perfect timing correlation\n  if (diffHours <= 24) return 0.8 // Strong correlation\n  if (diffHours <= 72) return 0.5 // Moderate correlation\n  return 0.2 // Weak correlation\n}\n\nfunction calculateSeverityScore(weatherEvents: any[]): number {\n  let score = 0\n  \n  for (const event of weatherEvents) {\n    switch (event.type) {\n      case 'storm_event':\n        if (event.severity === 'severe') score += 80\n        else if (event.severity === 'moderate') score += 50\n        else score += 30\n        break\n      case 'severe_weather':\n        if (event.max_wind_speed > 50) score += 70\n        else if (event.max_wind_speed > 25) score += 40\n        if (event.max_precipitation > 50) score += 60\n        else if (event.max_precipitation > 25) score += 30\n        break\n      case 'lightning_activity':\n        if (event.close_strikes > 5) score += 60\n        else if (event.nearby_strikes > 20) score += 40\n        else score += 20\n        break\n      case 'flooding':\n        score += 70\n        break\n    }\n  }\n  \n  return Math.min(100, score)\n}\n\nfunction determineEvidenceStrength(weatherEvents: any[], claim: any): string {\n  if (weatherEvents.length === 0) return 'none'\n  \n  const hasDirectEvidence = weatherEvents.some(e => e.relevance === 'direct')\n  const severityScore = calculateSeverityScore(weatherEvents)\n  \n  if (hasDirectEvidence && severityScore >= 70) return 'strong'\n  if (hasDirectEvidence || severityScore >= 50) return 'moderate'\n  if (severityScore >= 30) return 'weak'\n  return 'minimal'\n}\n\nfunction generateEventsSummary(weatherEvents: any[]): string {\n  if (weatherEvents.length === 0) return 'No significant weather events found'\n  \n  const eventTypes = [...new Set(weatherEvents.map(e => e.type))]\n  return `${weatherEvents.length} weather events detected: ${eventTypes.join(', ')}`\n}\n\nfunction generateWeatherTimeline(weatherEvents: any[], claimDate: string): any[] {\n  // Create a timeline of weather events around the claim date\n  return weatherEvents.map(event => ({\n    type: event.type,\n    time: event.event?.effective || event.observations?.[0]?.observation_time || claimDate,\n    severity: event.severity,\n    description: getEventDescription(event)\n  })).sort((a, b) => new Date(a.time).getTime() - new Date(b.time).getTime())\n}\n\nfunction getEventDescription(event: any): string {\n  switch (event.type) {\n    case 'storm_event':\n      return `${event.event.event_type}: ${event.event.headline}`\n    case 'severe_weather':\n      return `Severe weather observed: max wind ${event.max_wind_speed} m/s, precipitation ${event.max_precipitation} mm`\n    case 'lightning_activity':\n      return `Lightning activity: ${event.close_strikes} strikes within 5km, ${event.nearby_strikes} within 20km`\n    case 'flooding':\n      return `Flooding conditions detected at ${event.gauges.length} river gauges`\n    default:\n      return 'Weather event'\n  }\n}\n\nfunction extractStationData(weatherEvents: any[]): any[] {\n  const stations = []\n  for (const event of weatherEvents) {\n    if (event.station_distances) {\n      stations.push(...event.station_distances)\n    }\n  }\n  return stations\n}\n\nfunction extractConditionsData(weatherEvents: any[]): any {\n  const conditions = {\n    max_wind_speed: 0,\n    max_precipitation: 0,\n    lightning_strikes: 0,\n    flooding_detected: false\n  }\n  \n  for (const event of weatherEvents) {\n    if (event.max_wind_speed) conditions.max_wind_speed = Math.max(conditions.max_wind_speed, event.max_wind_speed)\n    if (event.max_precipitation) conditions.max_precipitation = Math.max(conditions.max_precipitation, event.max_precipitation)\n    if (event.type === 'lightning_activity') conditions.lightning_strikes += event.total_strikes\n    if (event.type === 'flooding') conditions.flooding_detected = true\n  }\n  \n  return conditions\n}\n\nfunction extractWarningsData(weatherEvents: any[]): any[] {\n  return weatherEvents\n    .filter(e => e.type === 'storm_event')\n    .map(e => ({\n      type: e.event.event_type,\n      headline: e.event.headline,\n      effective: e.event.effective,\n      expires: e.event.expires\n    }))\n}\n\nfunction analyzeDamageWeatherMatch(claim: any, weatherEvents: any[]): string {\n  const claimType = claim.claim_type?.toLowerCase() || ''\n  const eventTypes = weatherEvents.map(e => e.type)\n  \n  if (claimType.includes('wind') && eventTypes.includes('severe_weather')) return 'strong_match'\n  if (claimType.includes('water') && eventTypes.includes('flooding')) return 'strong_match'\n  if (claimType.includes('storm') && eventTypes.includes('storm_event')) return 'strong_match'\n  if (eventTypes.length > 0) return 'possible_match'\n  return 'no_match'\n}\n\nfunction analyzeEventTiming(claimDate: string, weatherEvents: any[]): string {\n  if (weatherEvents.length === 0) return 'no_events'\n  \n  const claimTime = new Date(claimDate).getTime()\n  const eventTimes = weatherEvents.map(e => {\n    const eventTime = new Date(e.event?.effective || e.observations?.[0]?.observation_time || claimDate)\n    return Math.abs(claimTime - eventTime.getTime()) / (60 * 60 * 1000) // hours\n  })\n  \n  const minTimeDiff = Math.min(...eventTimes)\n  \n  if (minTimeDiff <= 6) return 'concurrent'\n  if (minTimeDiff <= 24) return 'same_day'\n  if (minTimeDiff <= 72) return 'within_3_days'\n  return 'distant'\n}\n\nfunction analyzeGeographicRelevance(property: any, weatherEvents: any[]): string {\n  const hasDirectEvents = weatherEvents.some(e => e.relevance === 'direct')\n  const hasNearbyEvents = weatherEvents.some(e => e.relevance === 'nearby')\n  \n  if (hasDirectEvents) return 'property_affected'\n  if (hasNearbyEvents) return 'local_area'\n  if (weatherEvents.length > 0) return 'regional'\n  return 'none'\n}\n\nfunction generateClaimRecommendations(claim: any, weatherData: any): string[] {\n  const recommendations = []\n  const events = weatherData.weather_events\n  \n  if (events.some(e => e.type === 'storm_event')) {\n    recommendations.push('Official weather warnings were in effect - strong supporting evidence')\n  }\n  \n  if (events.some(e => e.type === 'severe_weather' && e.max_wind_speed > 50)) {\n    recommendations.push('Extreme wind conditions recorded - consistent with structural damage claims')\n  }\n  \n  if (events.some(e => e.type === 'lightning_activity' && e.close_strikes > 0)) {\n    recommendations.push('Lightning strikes detected near property - relevant for electrical damage claims')\n  }\n  \n  if (events.some(e => e.type === 'flooding')) {\n    recommendations.push('Flooding conditions documented - supports water damage claims')\n  }\n  \n  if (recommendations.length === 0) {\n    recommendations.push('Limited weather evidence found - may require additional documentation')\n  }\n  \n  return recommendations\n}\n\nasync function analyzeClaimSeverityPatterns(supabase: any) {\n  // Analyze patterns between weather severity and claim amounts\n  const { data: correlations, error } = await supabase\n    .from('weather_claim_correlations')\n    .select(`\n      *,\n      claims!inner(estimated_amount, claim_type)\n    `)\n    .not('severity_score', 'is', null)\n    .limit(100)\n\n  if (error) throw error\n\n  const analysis = {\n    total_claims: correlations.length,\n    severity_distribution: {},\n    average_amounts_by_severity: {},\n    evidence_strength_distribution: {},\n    patterns: []\n  }\n\n  // Group by severity scores\n  const severityGroups = {\n    'low': correlations.filter(c => c.severity_score < 30),\n    'moderate': correlations.filter(c => c.severity_score >= 30 && c.severity_score < 70),\n    'high': correlations.filter(c => c.severity_score >= 70)\n  }\n\n  for (const [severity, group] of Object.entries(severityGroups)) {\n    analysis.severity_distribution[severity] = group.length\n    analysis.average_amounts_by_severity[severity] = \n      group.reduce((sum, c) => sum + (c.claims.estimated_amount || 0), 0) / group.length\n  }\n\n  // Evidence strength distribution\n  const evidenceGroups = correlations.reduce((acc, c) => {\n    const strength = c.evidence_strength\n    if (!acc[strength]) acc[strength] = 0\n    acc[strength]++\n    return acc\n  }, {})\n  analysis.evidence_strength_distribution = evidenceGroups\n\n  return new Response(\n    JSON.stringify(analysis),\n    { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n  )\n}"
